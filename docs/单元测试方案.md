# 股票代币报价系统 - 单元测试方案

> 版本：V1.0 | 日期：2026年1月

---

## 一、测试概述

### 1.1 测试目标

本单元测试方案旨在验证股票代币报价系统的核心业务功能逻辑和重要业务流程，确保系统在各种场景下都能正确工作。

**主要测试目标**：
- 验证数据源选择逻辑的正确性
- 验证加权价格计算的准确性
- 验证价格校验规则的完整性
- 验证数据源切换流程的可靠性
- 验证异常处理机制的有效性
- 验证价格瘦身和批量推送逻辑的正确性

### 1.2 测试范围

**核心模块测试**：
- ✅ 状态管理模块（`internal/state`）
- ✅ 价格计算模块（`internal/price`）
- ✅ 价格校验模块（`internal/price`）
- ✅ 价格格式化模块（`internal/price`）
- ✅ 价格瘦身模块（`internal/throttle`）
- ✅ 批量收集模块（`internal/batch`）
- ✅ 核心服务模块（`internal/oracle`）

**业务流程测试**：
- ✅ 数据源选择流程
- ✅ 数据源切换流程
- ✅ 加权价格计算流程
- ✅ 价格推送流程
- ✅ 异常处理流程

**不测试范围**：
- ❌ 外部依赖集成测试（CEX API、Pyth Network、Gate.io、Redis、Injective Chain）
- ❌ 端到端集成测试
- ❌ 性能测试
- ❌ 压力测试

### 1.3 测试框架和工具

**测试框架**：
- Go 标准库 `testing`
- 断言库：`github.com/stretchr/testify/assert`
- Mock 框架：`github.com/stretchr/testify/mock`

**辅助工具**：
- 时间控制：`github.com/benbjohnson/clock`（用于时间相关的测试）
- Redis Mock：内存 Redis 或 `github.com/alicebob/miniredis/v2`
- HTTP Mock：`github.com/jarcoal/httpmock`

**测试覆盖率目标**：
- 核心业务逻辑模块：**≥ 80%**
- 工具类模块：**≥ 90%**
- 整体覆盖率：**≥ 75%**

---

## 二、测试用例设计

### 2.1 状态管理模块测试（`internal/state`）

#### 2.1.1 数据源选择逻辑测试

**测试用例 1.1：市场交易时段 + 股票正常 → CEX报价**
- **输入**：市场状态 = `pre_hour_trading`，股票状态 = `normal`
- **预期**：数据源 = `CEX`，不暂停
- **验证点**：
  - `decideDataSource()` 返回 `DataSourceCEX, false, ""`
  - 触发数据源切换回调（如果从其他数据源切换）

**测试用例 1.2：市场交易时段 + 股票熔断 → 加权合成报价**
- **输入**：市场状态 = `trading`，股票状态 = `circuit_breaker`
- **预期**：数据源 = `WEIGHTED`，不暂停
- **验证点**：
  - `decideDataSource()` 返回 `DataSourceWeighted, false, ""`
  - 触发数据源切换回调

**测试用例 1.3：市场交易时段 + 股票其他状态 → 暂停报价**
- **输入**：市场状态 = `trading`，股票状态 = `halted`
- **预期**：数据源 = `CEX`，暂停 = `true`，原因 = "股票状态异常: halted"
- **验证点**：
  - `decideDataSource()` 返回 `DataSourceCEX, true, "股票状态异常: halted"`
  - 发送告警

**测试用例 1.4：市场非交易时段 + 股票正常 → 加权合成报价**
- **输入**：市场状态 = `not_yet_open`，股票状态 = `normal`
- **预期**：数据源 = `WEIGHTED`，不暂停
- **验证点**：
  - `decideDataSource()` 返回 `DataSourceWeighted, false, ""`

**测试用例 1.5：市场非交易时段 + 股票熔断 → 加权合成报价**
- **输入**：市场状态 = `market_closed`，股票状态 = `circuit_breaker`
- **预期**：数据源 = `WEIGHTED`，不暂停
- **验证点**：
  - `decideDataSource()` 返回 `DataSourceWeighted, false, ""`

**测试用例 1.6：市场非交易时段 + 股票其他状态 → 暂停报价**
- **输入**：市场状态 = `market_closed`，股票状态 = `suspended`
- **预期**：数据源 = `WEIGHTED`，暂停 = `true`，原因 = "股票状态异常: suspended"
- **验证点**：
  - `decideDataSource()` 返回 `DataSourceWeighted, true, "股票状态异常: suspended"`
  - 发送告警

**测试用例 1.7：所有交易时段状态识别**
- **输入**：市场状态 = `pre_hour_trading` / `trading` / `post_hour_trading` / `overnight_trading`
- **预期**：`IsTrading()` 返回 `true`
- **验证点**：
  - 每个状态都能正确识别为交易时段

**测试用例 1.8：所有非交易时段状态识别**
- **输入**：市场状态 = `not_yet_open` / `middle_close` / `closing` / `early_closed` / `market_closed`
- **预期**：`IsTrading()` 返回 `false`
- **验证点**：
  - 每个状态都能正确识别为非交易时段

#### 2.1.2 数据源切换流程测试

**测试用例 2.1：CEX → 加权合成切换**
- **前置条件**：当前数据源 = `CEX`，市场状态变为 `market_closed`
- **步骤**：
  1. 调用 `updateStatus(market_closed, {AAPLX: normal})`
  2. 触发数据源切换回调
- **预期**：
  - 数据源切换为 `WEIGHTED`
  - 触发切换回调，传入 `(CEX, WEIGHTED, AAPLX)`
  - 捕获收盘价（从 CEX 缓存获取）

**测试用例 2.2：加权合成 → CEX 切换**
- **前置条件**：当前数据源 = `WEIGHTED`，市场状态变为 `pre_hour_trading`，股票状态 = `normal`
- **步骤**：
  1. 调用 `updateStatus(pre_hour_trading, {AAPLX: normal})`
  2. 触发数据源切换回调
- **预期**：
  - 数据源切换为 `CEX`
  - 触发切换回调，传入 `(WEIGHTED, CEX, AAPLX)`
  - 执行5%差异检测

**测试用例 2.3：相同数据源不触发切换**
- **前置条件**：当前数据源 = `CEX`，市场状态仍为 `trading`，股票状态仍为 `normal`
- **步骤**：调用 `updateStatus(trading, {AAPLX: normal})`
- **预期**：不触发切换回调，数据源保持 `CEX`

**测试用例 2.4：按股票独立管理数据源**
- **前置条件**：AAPLX 使用 `CEX`，NVDAX 使用 `WEIGHTED`
- **步骤**：调用 `updateStatus(trading, {AAPLX: normal, NVDAX: circuit_breaker})`
- **预期**：
  - AAPLX 数据源 = `CEX`
  - NVDAX 数据源 = `WEIGHTED`
  - 两个股票独立判断，互不影响

#### 2.1.3 暂停/恢复报价测试

**测试用例 3.1：暂停报价**
- **步骤**：调用 `PauseStock("AAPLX", "测试暂停")`
- **预期**：
  - `IsPaused("AAPLX")` 返回 `true`
  - `GetPauseReason("AAPLX")` 返回 `"测试暂停"`

**测试用例 3.2：恢复报价**
- **前置条件**：AAPLX 已暂停
- **步骤**：市场状态变为正常，股票状态变为 `normal`
- **预期**：
  - `IsPaused("AAPLX")` 返回 `false`
  - 触发恢复日志

**测试用例 3.3：暂停状态查询**
- **步骤**：查询未暂停的股票
- **预期**：`IsPaused("TSLAX")` 返回 `false`

---

### 2.2 价格计算模块测试（`internal/price`）

#### 2.2.1 加权价格计算测试

**测试用例 4.1：正常权重计算（收盘价40% + Pyth30% + Gate30%）**
- **输入**：
  - 收盘价 = 100.0，状态 = `NORMAL`
  - Pyth价格 = 101.0，状态 = `NORMAL`
  - Gate价格 = 102.0，状态 = `NORMAL`
- **预期**：
  - 收盘价权重 = 0.4
  - Pyth权重 = 0.3
  - Gate权重 = 0.3
  - 加权价格 = 100.0×0.4 + 101.0×0.3 + 102.0×0.3 = 100.9
  - `IsDegraded` = `false`

**测试用例 4.2：Pyth异常降权（收盘价60% + Gate40%）**
- **输入**：
  - 收盘价 = 100.0，状态 = `NORMAL`
  - Pyth价格 = 0（异常），状态 = `ABNORMAL`
  - Gate价格 = 102.0，状态 = `NORMAL`
- **预期**：
  - 收盘价权重 = 0.6
  - Pyth权重 = 0
  - Gate权重 = 0.4
  - 加权价格 = 100.0×0.6 + 102.0×0.4 = 100.8
  - `IsDegraded` = `true`
  - `DegradeReason` = `"Pyth价格异常"`

**测试用例 4.3：Gate异常降权（收盘价60% + Pyth40%）**
- **输入**：
  - 收盘价 = 100.0，状态 = `NORMAL`
  - Pyth价格 = 101.0，状态 = `NORMAL`
  - Gate价格 = 0（异常），状态 = `ABNORMAL`
- **预期**：
  - 收盘价权重 = 0.6
  - Pyth权重 = 0.4
  - Gate权重 = 0
  - 加权价格 = 100.0×0.6 + 101.0×0.4 = 100.4
  - `IsDegraded` = `true`
  - `DegradeReason` = `"Gate价格异常"`

**测试用例 4.4：收盘价异常降权（Pyth50% + Gate50%）**
- **输入**：
  - 收盘价 = 0（异常）
  - Pyth价格 = 101.0，状态 = `NORMAL`
  - Gate价格 = 102.0，状态 = `NORMAL`
- **预期**：
  - 收盘价权重 = 0
  - Pyth权重 = 0.5
  - Gate权重 = 0.5
  - 加权价格 = 101.0×0.5 + 102.0×0.5 = 101.5
  - `IsDegraded` = `true`
  - `DegradeReason` = `"CEX收盘价异常"`

**测试用例 4.5：两个预言机都异常**
- **输入**：
  - 收盘价 = 100.0，状态 = `NORMAL`
  - Pyth价格 = 0（异常），状态 = `ABNORMAL`
  - Gate价格 = 0（异常），状态 = `ABNORMAL`
- **预期**：
  - 加权价格 = 0
  - `IsDegraded` = `true`
  - `DegradeReason` = `"两个预言机都异常"`

**测试用例 4.6：边界值测试**
- **输入**：收盘价 = 0.0001，Pyth = 0.0002，Gate = 0.0003
- **预期**：能正确计算加权价格，不出现除零错误

#### 2.2.2 价格跳变检测测试

**测试用例 5.1：正常价格变动（跳变 ≤ 10%）**
- **输入**：上次价格 = 100.0，当前价格 = 105.0
- **预期**：
  - 跳变百分比 = 5%
  - `CheckPriceJump()` 返回 `(0.05, false)`（false表示未异常）

**测试用例 5.2：价格跳变异常（跳变 > 10%）**
- **输入**：上次价格 = 100.0，当前价格 = 115.0
- **预期**：
  - 跳变百分比 = 15%
  - `CheckPriceJump()` 返回 `(0.15, true)`（true表示异常）

**测试用例 5.3：价格下跌跳变**
- **输入**：上次价格 = 100.0，当前价格 = 85.0
- **预期**：
  - 跳变百分比 = 15%（绝对值）
  - `CheckPriceJump()` 返回 `(0.15, true)`

**测试用例 5.4：首次价格（无上次价格）**
- **输入**：上次价格 = 0，当前价格 = 100.0
- **预期**：
  - 跳变百分比 = 0
  - `CheckPriceJump()` 返回 `(0, false)`（认为正常）

**测试用例 5.5：边界值测试（跳变 = 10%）**
- **输入**：上次价格 = 100.0，当前价格 = 110.0
- **预期**：
  - 跳变百分比 = 10%
  - `CheckPriceJump()` 返回 `(0.10, false)`（10%为正常阈值）

---

### 2.3 价格校验模块测试（`internal/price`）

#### 2.3.1 价格有效性校验

**测试用例 6.1：正常价格（> 0）**
- **输入**：价格 = 100.5
- **预期**：`ValidatePrice()` 返回 `nil`

**测试用例 6.2：价格 = 0**
- **输入**：价格 = 0
- **预期**：`ValidatePrice()` 返回错误，错误信息包含 "价格必须大于0"

**测试用例 6.3：价格 < 0**
- **输入**：价格 = -10.0
- **预期**：`ValidatePrice()` 返回错误

**测试用例 6.4：极小正数**
- **输入**：价格 = 0.0001
- **预期**：`ValidatePrice()` 返回 `nil`

#### 2.3.2 时间戳校验

**测试用例 7.1：正常时间戳（< 5分钟）**
- **输入**：时间戳 = `time.Now().Add(-2 * time.Minute)`
- **预期**：`ValidateTimestamp()` 返回 `nil`

**测试用例 7.2：时间戳过期（> 5分钟）**
- **输入**：时间戳 = `time.Now().Add(-6 * time.Minute)`
- **预期**：`ValidateTimestamp()` 返回错误，错误信息包含 "时间戳与系统时间相差过大"

**测试用例 7.3：未来时间戳（< 5分钟）**
- **输入**：时间戳 = `time.Now().Add(2 * time.Minute)`
- **预期**：`ValidateTimestamp()` 返回 `nil`（取绝对值）

**测试用例 7.4：未来时间戳（> 5分钟）**
- **输入**：时间戳 = `time.Now().Add(6 * time.Minute)`
- **预期**：`ValidateTimestamp()` 返回错误

#### 2.3.3 切换价格差异校验

**测试用例 8.1：正常切换差异（< 5%）**
- **输入**：上次价格 = 100.0，新价格 = 103.0
- **预期**：
  - 差异百分比 = 3%
  - `ValidateSwitchDiff()` 返回 `(0.03, true, nil)`

**测试用例 8.2：切换差异过大（≥ 5%）**
- **输入**：上次价格 = 100.0，新价格 = 106.0
- **预期**：
  - 差异百分比 = 6%
  - `ValidateSwitchDiff()` 返回 `(0.06, false, error)`
  - 错误信息包含 "切换价格差异过大"

**测试用例 8.3：首次切换（无上次价格）**
- **输入**：上次价格 = 0，新价格 = 100.0
- **预期**：
  - `ValidateSwitchDiff()` 返回 `(0, true, nil)`（不需要校验）

**测试用例 8.4：价格下跌差异**
- **输入**：上次价格 = 100.0，新价格 = 94.0
- **预期**：
  - 差异百分比 = 6%（绝对值）
  - `ValidateSwitchDiff()` 返回 `(0.06, false, error)`

**测试用例 8.5：边界值测试（差异 = 5%）**
- **输入**：上次价格 = 100.0，新价格 = 105.0
- **预期**：
  - 差异百分比 = 5%
  - `ValidateSwitchDiff()` 返回 `(0.05, false, error)`（5%为阈值，不通过）

---

### 2.4 价格格式化模块测试（`internal/price`）

#### 2.4.1 价格格式化规则

**测试用例 9.1：价格 < 1，保留4位小数（舍位）**
- **输入**：价格 = 0.12345
- **预期**：`FormatPrice()` 返回 `0.1234`

**测试用例 9.2：价格 < 1，边界值**
- **输入**：价格 = 0.9999
- **预期**：`FormatPrice()` 返回 `0.9999`

**测试用例 9.3：价格 ≥ 1，保留2位小数（舍位）**
- **输入**：价格 = 180.567
- **预期**：`FormatPrice()` 返回 `180.56`

**测试用例 9.4：价格 ≥ 1，整数部分**
- **输入**：价格 = 100.0
- **预期**：`FormatPrice()` 返回 `100.0`

**测试用例 9.5：价格 = 1，边界值**
- **输入**：价格 = 1.0
- **预期**：`FormatPrice()` 返回 `1.0`

**测试用例 9.6：价格 = 0.9999，边界值**
- **输入**：价格 = 0.9999
- **预期**：`FormatPrice()` 返回 `0.9999`（< 1，保留4位）

**测试用例 9.7：价格 = 1.0001，边界值**
- **输入**：价格 = 1.0001
- **预期**：`FormatPrice()` 返回 `1.0`（≥ 1，保留2位）

---

### 2.5 价格瘦身模块测试（`internal/throttle`）

#### 2.5.1 推送决策逻辑

**测试用例 10.1：首次推送**
- **前置条件**：无历史推送记录
- **输入**：价格 = 100.0
- **预期**：
  - `ShouldPush()` 返回 `{ShouldPush: true, Reason: "首次推送"}`

**测试用例 10.2：强制立即推送（数据源切换）**
- **前置条件**：上次推送价格 = 100.0，时间 = 0.5秒前
- **输入**：价格 = 100.1，`forceImmediate = true`
- **预期**：
  - `ShouldPush()` 返回 `{ShouldPush: true, Reason: "数据源切换，强制推送"}`

**测试用例 10.3：超过最大间隔（心跳推送）**
- **前置条件**：上次推送时间 = 4秒前（超过3秒最大间隔）
- **输入**：价格 = 100.0（价格未变）
- **预期**：
  - `ShouldPush()` 返回 `{ShouldPush: true, Reason: "超过最大间隔，心跳推送"}`

**测试用例 10.4：超过最小间隔且价格变动 > 0.3%**
- **前置条件**：上次推送价格 = 100.0，时间 = 1.5秒前
- **输入**：价格 = 100.5（变动0.5% > 0.3%）
- **预期**：
  - `ShouldPush()` 返回 `{ShouldPush: true, Reason: "价格变动超过阈值"}`

**测试用例 10.5：超过最小间隔但价格变动 < 0.3%**
- **前置条件**：上次推送价格 = 100.0，时间 = 1.5秒前
- **输入**：价格 = 100.2（变动0.2% < 0.3%）
- **预期**：
  - `ShouldPush()` 返回 `{ShouldPush: false, Reason: "价格变动过小，跳过"}`

**测试用例 10.6：未超过最小间隔**
- **前置条件**：上次推送时间 = 0.5秒前（< 1秒最小间隔）
- **输入**：价格 = 105.0（变动5%）
- **预期**：
  - `ShouldPush()` 返回 `{ShouldPush: false, Reason: "未超过最小推送间隔，跳过"}`

**测试用例 10.7：价格下跌变动**
- **前置条件**：上次推送价格 = 100.0，时间 = 1.5秒前
- **输入**：价格 = 99.5（变动0.5%，绝对值）
- **预期**：
  - `ShouldPush()` 返回 `{ShouldPush: true, Reason: "价格变动超过阈值"}`

#### 2.5.2 状态更新测试

**测试用例 11.1：确认推送后更新状态**
- **步骤**：
  1. 调用 `ShouldPush("AAPLX", 100.0, "CEX", false)` → 返回 `ShouldPush: true`
  2. 调用 `ConfirmPush("AAPLX", 100.0)`
- **预期**：
  - `GetLastPushPrice("AAPLX")` 返回 `100.0`
  - `GetLastPushTime("AAPLX")` 返回当前时间（近似）

**测试用例 11.2：重置状态**
- **前置条件**：AAPLX 有推送记录
- **步骤**：调用 `Reset("AAPLX")`
- **预期**：
  - `GetLastPushPrice("AAPLX")` 返回 `0`
  - 下次推送视为首次推送

---

### 2.6 批量收集模块测试（`internal/batch`）

#### 2.6.1 价格收集和去重

**测试用例 12.1：添加价格到缓冲区**
- **步骤**：调用 `AddPrice("AAPLX", 100.0, "CEX")`
- **预期**：
  - `GetBufferedCount()` 返回 `1`
  - 缓冲区包含 AAPLX 的价格数据

**测试用例 12.2：同一股票价格更新（自动去重）**
- **步骤**：
  1. 调用 `AddPrice("AAPLX", 100.0, "CEX")`
  2. 调用 `AddPrice("AAPLX", 101.0, "CEX")`
- **预期**：
  - `GetBufferedCount()` 返回 `1`（去重，只保留最新）
  - 缓冲区中 AAPLX 的价格 = 101.0

**测试用例 12.3：多个股票价格收集**
- **步骤**：
  1. 调用 `AddPrice("AAPLX", 100.0, "CEX")`
  2. 调用 `AddPrice("NVDAX", 200.0, "CEX")`
  3. 调用 `AddPrice("TSLAX", 300.0, "CEX")`
- **预期**：
  - `GetBufferedCount()` 返回 `3`
  - 缓冲区包含三个股票的价格

**测试用例 12.4：缓冲区满时触发强制刷新**
- **前置条件**：`maxBufferSize = 3`
- **步骤**：
  1. 添加3个股票价格
  2. 添加第4个股票价格
- **预期**：
  - 触发强制刷新（`forceFlush()`）
  - 记录日志 "缓冲区已满"

#### 2.6.2 定时刷新测试

**测试用例 13.1：定时刷新（1秒间隔）**
- **前置条件**：`maxFlushInterval = 1秒`
- **步骤**：
  1. 启动收集器
  2. 添加价格
  3. 等待1.1秒
- **预期**：
  - 触发 `onFlush` 回调
  - 缓冲区被清空

**测试用例 13.2：手动强制刷新**
- **步骤**：
  1. 添加价格
  2. 调用 `ForceFlush()`
- **预期**：
  - 立即触发 `onFlush` 回调
  - 缓冲区被清空

**测试用例 13.3：空缓冲区不触发刷新**
- **步骤**：调用 `flush()`（缓冲区为空）
- **预期**：
  - 不调用 `onFlush` 回调
  - 直接返回

#### 2.6.3 停止和同步测试

**测试用例 14.1：停止时等待所有 flush 完成**
- **步骤**：
  1. 启动收集器
  2. 添加价格，触发 flush
  3. 调用 `Stop()`
- **预期**：
  - 等待所有 `onFlush` 回调完成
  - 最多等待35秒（超时保护）
  - 关闭 `done` channel

**测试用例 14.2：停止时刷新剩余数据**
- **步骤**：
  1. 添加价格到缓冲区
  2. 调用 `Stop()`
- **预期**：
  - 触发最后一次 `flush()`
  - 缓冲区中的数据被推送到 `onFlush`

---

### 2.7 核心服务模块测试（`internal/oracle`）

#### 2.7.1 CEX报价处理流程

**测试用例 15.1：正常CEX报价处理**
- **前置条件**：
  - 系统已就绪
  - 当前数据源 = `CEX`
- **输入**：CEX报价消息（价格 = 100.0，时间戳 = 当前时间）
- **预期**：
  - 价格校验通过
  - 时间戳校验通过
  - 价格格式化
  - 添加到批量收集器

**测试用例 15.2：CEX价格无效（≤ 0）**
- **输入**：CEX报价消息（价格 = 0）
- **预期**：
  - 价格校验失败
  - 发送告警
  - 不添加到批量收集器

**测试用例 15.3：CEX时间戳过期**
- **输入**：CEX报价消息（时间戳 = 6分钟前）
- **预期**：
  - 时间戳校验失败
  - 发送告警
  - 不添加到批量收集器

**测试用例 15.4：系统未就绪时丢弃数据**
- **前置条件**：系统未就绪（`isReady = false`）
- **输入**：CEX报价消息
- **预期**：
  - 直接返回，不处理
  - 不缓存报价

**测试用例 15.5：不同市场状态的价格字段选择**
- **测试场景 15.5.1：Regular（盘中）**
  - **输入**：`marketStatus = "Regular"`，`latest_price = 100.0`
  - **预期**：`GetCurrentPrice()` 返回 `100.0`
- **测试场景 15.5.2：PreMarket（盘前）**
  - **输入**：`marketStatus = "PreMarket"`，`bid_price = 99.0`
  - **预期**：`GetCurrentPrice()` 返回 `99.0`
- **测试场景 15.5.3：AfterHours（盘后）**
  - **输入**：`marketStatus = "AfterHours"`，`bid_price = 101.0`
  - **预期**：`GetCurrentPrice()` 返回 `101.0`
- **测试场景 15.5.4：OverNight（夜盘）**
  - **输入**：`marketStatus = "OverNight"`，`blue_price = 100.5`
  - **预期**：`GetCurrentPrice()` 返回 `100.5`

#### 2.7.2 Pyth价格处理流程

**测试用例 16.1：正常Pyth价格处理**
- **前置条件**：
  - 系统已就绪
  - 当前数据源 = `WEIGHTED`
  - 上次Pyth价格 = 100.0
- **输入**：Pyth价格（价格 = 101.0，时间戳 = 当前时间）
- **预期**：
  - 价格校验通过
  - 时间戳校验通过
  - 价格跳变检测（1% < 10%，正常）
  - 更新Pyth缓存
  - 触发加权价格计算

**测试用例 16.2：Pyth价格跳变异常（> 10%）**
- **前置条件**：上次Pyth价格 = 100.0
- **输入**：Pyth价格（价格 = 115.0，跳变15%）
- **预期**：
  - 价格跳变检测异常
  - 不更新Pyth缓存（保留上次正常价格）
  - 标记Pyth状态为 `ABNORMAL`
  - 使用降级权重计算加权价格
  - 记录日志（首次异常时）

**测试用例 16.3：Pyth价格恢复（跳变 ≤ 10%）**
- **前置条件**：
  - Pyth状态 = `ABNORMAL`
  - 上次正常价格 = 100.0
- **输入**：Pyth价格（价格 = 105.0，跳变5%）
- **预期**：
  - 价格跳变检测正常
  - 更新Pyth缓存
  - 标记Pyth状态为 `NORMAL`
  - 恢复正常权重
  - 记录恢复日志

**测试用例 16.4：首次Pyth价格（无上次价格）**
- **前置条件**：无Pyth价格缓存
- **输入**：Pyth价格（价格 = 100.0）
- **预期**：
  - 价格跳变检测正常（无上次价格，认为正常）
  - 更新Pyth缓存
  - 标记Pyth状态为 `NORMAL`

#### 2.7.3 Gate价格处理流程

**测试用例 17.1-17.4：与Pyth相同的测试场景**
- 参考测试用例 16.1-16.4，将Pyth替换为Gate

#### 2.7.4 数据源切换流程

**测试用例 18.1：CEX → 加权合成切换**
- **前置条件**：
  - 当前数据源 = `CEX`
  - 最后推送价格 = 100.0
  - CEX缓存中有报价（`marketStatus = "Regular"`，`latest_price = 100.5`）
- **步骤**：
  1. 状态管理检测到需要切换到加权合成
  2. 触发数据源切换回调
- **预期**：
  - 捕获收盘价 = 100.5（从CEX缓存获取）
  - 收盘价写入Redis
  - 更新内存收盘价缓存
  - 执行5%差异检测（100.0 vs 100.5，差异0.5% < 5%，通过）
  - 强制立即推送（`forceImmediate = true`）
  - 触发批量收集器强制刷新

**测试用例 18.2：加权合成 → CEX切换**
- **前置条件**：
  - 当前数据源 = `WEIGHTED`
  - 最后推送价格 = 100.0
  - CEX缓存中有报价（`marketStatus = "Regular"`，`latest_price = 100.5`）
- **步骤**：
  1. 状态管理检测到需要切换到CEX
  2. 触发数据源切换回调
- **预期**：
  - 从CEX缓存获取价格 = 100.5
  - 格式化价格
  - 执行5%差异检测（100.0 vs 100.5，差异0.5% < 5%，通过）
  - 强制立即推送
  - 触发批量收集器强制刷新

**测试用例 18.3：切换价格差异过大（≥ 5%）**
- **前置条件**：
  - 当前数据源 = `CEX`
  - 最后推送价格 = 100.0
  - CEX缓存中有报价（价格 = 106.0，差异6%）
- **步骤**：触发数据源切换回调
- **预期**：
  - 5%差异检测失败（差异6% ≥ 5%）
  - 回滚数据源到原状态（保持 `CEX`）
  - 暂停该股票报价
  - 发送告警
  - 不推送价格

**测试用例 18.4：切换时无CEX缓存**
- **前置条件**：
  - 当前数据源 = `CEX`
  - CEX缓存中没有报价
- **步骤**：触发数据源切换回调
- **预期**：
  - 记录日志 "没有CEX报价缓存"
  - 不执行切换

**测试用例 18.5：切换时收盘价获取（不同marketStatus）**
- **测试场景 18.5.1：PreMarket → bid_price**
  - **输入**：`marketStatus = "PreMarket"`，`bid_price = 99.0`
  - **预期**：捕获收盘价 = 99.0
- **测试场景 18.5.2：Regular → latest_price**
  - **输入**：`marketStatus = "Regular"`，`latest_price = 100.0`
  - **预期**：捕获收盘价 = 100.0
- **测试场景 18.5.3：AfterHours → bid_price**
  - **输入**：`marketStatus = "AfterHours"`，`bid_price = 101.0`
  - **预期**：捕获收盘价 = 101.0
- **测试场景 18.5.4：OverNight → blue_price**
  - **输入**：`marketStatus = "OverNight"`，`blue_price = 100.5`
  - **预期**：捕获收盘价 = 100.5

#### 2.7.5 加权价格计算流程

**测试用例 19.1：正常加权价格计算**
- **前置条件**：
  - 当前数据源 = `WEIGHTED`
  - 收盘价缓存 = 100.0
  - Pyth价格 = 101.0，状态 = `NORMAL`
  - Gate价格 = 102.0，状态 = `NORMAL`
- **步骤**：Pyth价格更新，触发加权价格计算
- **预期**：
  - 计算加权价格 = 100.0×0.4 + 101.0×0.3 + 102.0×0.3 = 100.9
  - 价格格式化
  - 添加到批量收集器

**测试用例 19.2：两个预言机都异常**
- **前置条件**：
  - 当前数据源 = `WEIGHTED`
  - Pyth状态 = `ABNORMAL`
  - Gate状态 = `ABNORMAL`
- **步骤**：触发加权价格计算
- **预期**：
  - 加权价格 = 0
  - 暂停该股票报价
  - 发送告警（仅首次）
  - 不添加到批量收集器

**测试用例 19.3：两个预言机恢复**
- **前置条件**：
  - 当前数据源 = `WEIGHTED`
  - 股票已暂停（两个预言机都异常）
  - Pyth状态恢复为 `NORMAL`
- **步骤**：Pyth价格更新，触发加权价格计算
- **预期**：
  - 恢复该股票报价
  - 重置告警状态
  - 计算加权价格
  - 添加到批量收集器

**测试用例 19.4：收盘价异常时的降权**
- **前置条件**：
  - 当前数据源 = `WEIGHTED`
  - 收盘价缓存 = 0（异常）
  - Pyth价格 = 101.0，状态 = `NORMAL`
  - Gate价格 = 102.0，状态 = `NORMAL`
- **步骤**：触发加权价格计算
- **预期**：
  - 使用降级权重：Pyth50% + Gate50%
  - 加权价格 = 101.0×0.5 + 102.0×0.5 = 101.5
  - 记录日志（首次异常时，去重）

#### 2.7.6 批量推送流程

**测试用例 20.1：批量推送成功**
- **前置条件**：
  - 批量收集器中有3个股票价格
  - 所有股票都未暂停
- **步骤**：触发批量刷新
- **预期**：
  - 调用 `PushBatchPricesWithSources()` 推送3个股票
  - 推送成功后更新瘦身器状态
  - 更新 `lastPrices`
  - 记录成功日志

**测试用例 20.2：批量推送失败重试**
- **前置条件**：
  - 批量收集器中有价格
  - 链上推送失败（模拟网络错误）
- **步骤**：触发批量刷新
- **预期**：
  - 第1次推送失败
  - 等待100ms后重试
  - 第2次推送失败
  - 等待200ms后重试
  - 第3次推送成功
  - 记录重试日志

**测试用例 20.3：批量推送全部失败**
- **前置条件**：
  - 批量收集器中有价格
  - 链上推送连续3次失败
- **步骤**：触发批量刷新
- **预期**：
  - 重试3次后仍然失败
  - 发送告警（包含股票列表和错误信息）
  - 记录失败日志

**测试用例 20.4：过滤暂停的股票**
- **前置条件**：
  - 批量收集器中有3个股票价格
  - AAPLX 已暂停
- **步骤**：触发批量刷新
- **预期**：
  - 只推送 NVDAX 和 TSLAX
  - AAPLX 被过滤掉
  - 记录日志 "所有股票都被暂停，跳过推送"（如果全部暂停）

**测试用例 20.5：批量推送时应用瘦身逻辑**
- **前置条件**：
  - 批量收集器中有价格
  - 瘦身逻辑判断某些股票不需要推送
- **步骤**：在 `collectPrice` 时应用瘦身逻辑
- **预期**：
  - 只有通过瘦身判断的价格才会进入批量收集器
  - 批量推送时只推送通过瘦身判断的价格

---

### 2.8 业务流程集成测试

#### 2.8.1 完整数据源切换流程

**测试用例 21.1：CEX → 加权合成完整流程**
- **前置条件**：
  - 系统运行中，AAPLX 使用 CEX 报价
  - 最后推送价格 = 100.0
  - CEX缓存：`marketStatus = "Regular"`，`latest_price = 100.5`
- **步骤**：
  1. 状态管理检测到市场状态变为 `market_closed`
  2. 触发数据源切换
  3. 捕获收盘价
  4. 执行5%差异检测
  5. 计算加权价格
  6. 批量推送
- **预期**：
  - 数据源切换为 `WEIGHTED`
  - 收盘价 = 100.5，写入Redis
  - 5%差异检测通过
  - 加权价格计算成功
  - 强制立即推送
  - 批量推送成功

**测试用例 21.2：加权合成 → CEX完整流程**
- **前置条件**：
  - 系统运行中，AAPLX 使用加权合成报价
  - 最后推送价格 = 100.0
  - CEX缓存：`marketStatus = "PreMarket"`，`bid_price = 99.5`
- **步骤**：
  1. 状态管理检测到市场状态变为 `pre_hour_trading`，股票状态 = `normal`
  2. 触发数据源切换
  3. 从CEX缓存获取价格
  4. 执行5%差异检测
  5. 批量推送
- **预期**：
  - 数据源切换为 `CEX`
  - 价格 = 99.5，格式化
  - 5%差异检测通过（差异0.5% < 5%）
  - 强制立即推送
  - 批量推送成功

#### 2.8.2 异常恢复流程

**测试用例 22.1：Pyth异常 → 降权 → 恢复完整流程**
- **前置条件**：
  - 系统运行中，使用加权合成报价
  - Pyth价格 = 100.0（正常）
- **步骤**：
  1. Pyth价格跳变到115.0（跳变15% > 10%）
  2. 标记Pyth异常，使用降级权重
  3. Pyth价格恢复到105.0（跳变5% ≤ 10%）
- **预期**：
  - 步骤1：Pyth状态 = `ABNORMAL`，使用降级权重（收盘价60% + Gate40%）
  - 步骤2：记录降权日志（首次）
  - 步骤3：Pyth状态 = `NORMAL`，恢复正常权重（收盘价40% + Pyth30% + Gate30%）
  - 步骤3：记录恢复日志

**测试用例 22.2：两个预言机都异常 → 暂停 → 恢复**
- **前置条件**：
  - 系统运行中，使用加权合成报价
  - Pyth和Gate都正常
- **步骤**：
  1. Pyth价格跳变异常
  2. Gate价格跳变异常
  3. Pyth价格恢复
- **预期**：
  - 步骤1：Pyth异常，使用降级权重
  - 步骤2：两个都异常，暂停报价，发送告警（仅首次）
  - 步骤3：Pyth恢复，恢复报价，重置告警状态

---

## 三、Mock策略

### 3.1 外部依赖Mock

**Redis Mock**：
- 使用 `github.com/alicebob/miniredis/v2` 创建内存Redis服务器
- 模拟 `GetClosePrice()`、`SetClosePrice()` 等操作
- 支持TTL测试

**时间Mock**：
- 使用 `github.com/benbjohnson/clock` 控制时间
- 用于测试时间相关的逻辑（时间戳校验、定时刷新等）

**链上推送Mock**：
- 创建 `OnChainPusher` 的Mock实现
- 模拟推送成功/失败场景
- 支持重试测试

**告警服务Mock**：
- 创建 `LarkAlert` 的Mock实现
- 记录发送的告警，用于验证告警触发

**数据源客户端Mock**：
- CEX、Pyth、Gate客户端使用接口Mock
- 模拟连接、断开、数据推送等场景

### 3.2 测试数据准备

**市场状态测试数据**：
```go
var marketStatusTestCases = []struct {
    name         string
    marketStatus types.MarketStatus
    isTrading    bool
}{
    {"盘前", types.MarketStatusPreHourTrading, true},
    {"盘中", types.MarketStatusTrading, true},
    {"盘后", types.MarketStatusPostHourTrading, true},
    {"夜盘", types.MarketStatusOvernight, true},
    {"未开盘", types.MarketStatusNotYetOpen, false},
    {"休市", types.MarketStatusMarketClosed, false},
    // ...
}
```

**股票状态测试数据**：
```go
var stockStatusTestCases = []struct {
    name        string
    stockStatus types.StockStatus
    expectedDS  types.DataSource
    shouldPause bool
}{
    {"正常", types.StockStatusNormal, types.DataSourceCEX, false},
    {"熔断", types.StockStatusCircuitBreaker, types.DataSourceWeighted, false},
    {"停牌", types.StockStatusHalted, types.DataSourceCEX, true},
    // ...
}
```

**价格测试数据**：
```go
var priceTestCases = []struct {
    name      string
    price     float64
    valid     bool
    formatted float64
}{
    {"正常价格", 100.5, true, 100.5},
    {"价格=0", 0, false, 0},
    {"价格<1", 0.12345, true, 0.1234},
    {"价格≥1", 180.567, true, 180.56},
    // ...
}
```

---

## 四、测试文件组织

### 4.1 目录结构

```
test/unit/
├── state/
│   ├── manager_test.go          # 状态管理模块测试
│   └── manager_test_data.go     # 测试数据
├── price/
│   ├── calculator_test.go       # 价格计算模块测试
│   ├── validator_test.go        # 价格校验模块测试
│   ├── formatter_test.go        # 价格格式化模块测试
│   └── price_test_data.go       # 测试数据
├── throttle/
│   ├── throttle_test.go         # 价格瘦身模块测试
│   └── throttle_test_data.go    # 测试数据
├── batch/
│   ├── collector_test.go        # 批量收集模块测试
│   └── collector_test_data.go   # 测试数据
├── oracle/
│   ├── service_test.go          # 核心服务模块测试
│   ├── service_cex_test.go      # CEX报价处理测试
│   ├── service_pyth_test.go     # Pyth价格处理测试
│   ├── service_gate_test.go     # Gate价格处理测试
│   ├── service_switch_test.go   # 数据源切换测试
│   └── service_test_data.go     # 测试数据
├── mocks/
│   ├── storage_mock.go           # Redis存储Mock
│   ├── pusher_mock.go            # 链上推送Mock
│   ├── alert_mock.go             # 告警服务Mock
│   └── datasource_mock.go        # 数据源客户端Mock
└── helpers/
    ├── test_helpers.go           # 测试辅助函数
    └── clock_helper.go           # 时间控制辅助函数
```

### 4.2 测试文件命名规范

- 测试文件：`{模块名}_test.go`
- 测试函数：`Test{功能描述}`
- 测试数据文件：`{模块名}_test_data.go`
- Mock文件：`{接口名}_mock.go`

### 4.3 测试函数组织

每个测试文件按功能分组：

```go
func Test{模块名}_{功能1}(t *testing.T) {
    // 测试用例1.1
    // 测试用例1.2
    // ...
}

func Test{模块名}_{功能2}(t *testing.T) {
    // 测试用例2.1
    // 测试用例2.2
    // ...
}
```

---

## 五、测试执行计划

### 5.1 测试阶段划分

**第一阶段：核心模块单元测试**
- 状态管理模块
- 价格计算模块
- 价格校验模块
- 价格格式化模块
- **预计时间**：3-5天

**第二阶段：工具模块单元测试**
- 价格瘦身模块
- 批量收集模块
- **预计时间**：2-3天

**第三阶段：服务层单元测试**
- 核心服务模块（CEX/Pyth/Gate处理）
- 数据源切换流程
- 异常处理流程
- **预计时间**：5-7天

**第四阶段：业务流程集成测试**
- 完整数据源切换流程
- 异常恢复流程
- **预计时间**：2-3天

### 5.2 测试执行命令

**运行所有测试**：
```bash
go test ./test/unit/... -v
```

**运行特定模块测试**：
```bash
go test ./test/unit/state/... -v
go test ./test/unit/price/... -v
```

**生成覆盖率报告**：
```bash
go test ./test/unit/... -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html
```

**运行测试并查看覆盖率**：
```bash
go test ./test/unit/... -cover
```

### 5.3 持续集成

**CI/CD集成**：
- 每次代码提交自动运行单元测试
- 测试覆盖率低于目标时阻止合并
- 生成测试报告和覆盖率报告

---

## 六、测试覆盖率目标

### 6.1 模块覆盖率目标

| 模块 | 覆盖率目标 | 优先级 |
|------|-----------|--------|
| 状态管理模块 | ≥ 85% | 高 |
| 价格计算模块 | ≥ 90% | 高 |
| 价格校验模块 | ≥ 95% | 高 |
| 价格格式化模块 | ≥ 90% | 中 |
| 价格瘦身模块 | ≥ 85% | 中 |
| 批量收集模块 | ≥ 80% | 中 |
| 核心服务模块 | ≥ 75% | 高 |

### 6.2 业务场景覆盖率

**必须覆盖的场景**：
- ✅ 所有数据源选择组合（市场状态 × 股票状态）
- ✅ 所有加权价格计算场景（正常/降权）
- ✅ 所有价格校验规则
- ✅ 数据源切换流程（CEX ↔ 加权合成）
- ✅ 异常处理流程（价格跳变、两个预言机异常等）
- ✅ 价格瘦身逻辑（首次推送、心跳、价格变动等）

---

## 七、测试数据管理

### 7.1 测试数据分类

**静态测试数据**：
- 市场状态枚举值
- 股票状态枚举值
- 价格边界值（0, 0.0001, 1.0, 100.0等）

**动态测试数据**：
- 时间戳（使用Mock时钟控制）
- 价格序列（用于测试价格跳变）
- 状态序列（用于测试状态切换）

### 7.2 测试数据生成

**价格数据生成器**：
```go
func generatePriceSequence(basePrice float64, count int, changePercent float64) []float64 {
    // 生成价格序列，用于测试价格变动
}
```

**状态序列生成器**：
```go
func generateStatusSequence() []struct {
    marketStatus types.MarketStatus
    stockStatus  types.StockStatus
} {
    // 生成状态序列，用于测试状态切换
}
```

---

## 八、测试最佳实践

### 8.1 测试编写原则

1. **独立性**：每个测试用例应该独立，不依赖其他测试的执行顺序
2. **可重复性**：测试应该可以重复运行，结果一致
3. **快速执行**：单元测试应该快速执行（每个测试 < 100ms）
4. **清晰命名**：测试函数名应该清晰描述测试场景
5. **单一职责**：每个测试用例只测试一个功能点

### 8.2 测试代码组织

**使用表驱动测试**：
```go
func TestCalculateWeightedPrice(t *testing.T) {
    testCases := []struct {
        name        string
        closePrice  float64
        pythPrice   float64
        gatePrice   float64
        pythStatus  types.OracleStatus
        gateStatus  types.OracleStatus
        expected    float64
        isDegraded  bool
    }{
        {
            name:       "正常权重",
            closePrice: 100.0,
            pythPrice:  101.0,
            gatePrice:  102.0,
            pythStatus: types.OracleStatusNormal,
            gateStatus: types.OracleStatusNormal,
            expected:   100.9,
            isDegraded: false,
        },
        // ...
    }
    
    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            // 执行测试
        })
    }
}
```

**使用辅助函数**：
```go
func setupTestService(t *testing.T) *Service {
    // 创建测试用的Service实例
}

func teardownTestService(t *testing.T, svc *Service) {
    // 清理测试资源
}
```

### 8.3 断言和错误处理

**使用testify断言**：
```go
assert.Equal(t, expected, actual, "价格应该相等")
assert.NoError(t, err, "不应该有错误")
assert.True(t, result, "结果应该为true")
```

**错误信息要详细**：
```go
if !assert.Equal(t, expected, actual) {
    t.Errorf("价格计算错误: 期望 %.2f, 实际 %.2f", expected, actual)
}
```

---

## 九、测试环境要求

### 9.1 开发环境

- Go 1.21+
- 测试框架：`github.com/stretchr/testify`
- Mock工具：`github.com/stretchr/testify/mock`
- Redis Mock：`github.com/alicebob/miniredis/v2`
- 时间控制：`github.com/benbjohnson/clock`

### 9.2 依赖安装

```bash
go get github.com/stretchr/testify/assert
go get github.com/stretchr/testify/mock
go get github.com/alicebob/miniredis/v2
go get github.com/benbjohnson/clock
```

---

## 十、测试验收标准

### 10.1 功能验收

- ✅ 所有核心业务逻辑测试通过
- ✅ 所有重要业务流程测试通过
- ✅ 边界值和异常场景测试通过
- ✅ Mock外部依赖，测试不依赖真实服务

### 10.2 质量验收

- ✅ 测试覆盖率 ≥ 75%
- ✅ 核心模块覆盖率 ≥ 80%
- ✅ 所有测试用例独立可运行
- ✅ 测试执行时间 < 30秒

### 10.3 文档验收

- ✅ 测试用例文档完整
- ✅ 测试数据准备说明清晰
- ✅ Mock策略文档化
- ✅ 测试执行步骤明确

---

## 十一、附录

### 11.1 测试用例清单

**状态管理模块**：8个测试用例
**价格计算模块**：6个测试用例
**价格校验模块**：13个测试用例
**价格格式化模块**：7个测试用例
**价格瘦身模块**：9个测试用例
**批量收集模块**：6个测试用例
**核心服务模块**：20+个测试用例
**业务流程集成**：4个测试用例

**总计**：70+个测试用例

### 11.2 参考文档

- [产品需求文档](./股票代币报价系统产品需求文档.md)
- [技术方案文档](./技术方案文档.md)
- [产品补充说明](./对产品文档的补充说明.md)
- [Go Testing文档](https://pkg.go.dev/testing)
- [Testify文档](https://github.com/stretchr/testify)

---

**文档版本**：V1.0  
**最后更新**：2026年1月  
**维护者**：开发团队
